# 자바스크립트 중급

2021.12.16

# 목차

- 객체 반복문과 생성자
    
    자바스크립트 객체도 반복문을 돌릴 수 있다.
    
    자바스크립트에서 객체는 어떤 의미를 가지고 있을까?
    
    배열은 여러개의 데이터를 담고 있고 여러개의 데이터를 반복문을 사용할 때 거대한 작업을 할 수 있다. 
    
    객체또한 마찬가지이다.
    
    while 문은 처음에 i = 0 을 기본 베이스로 시작한다.
    
    i 의 값이 0 부터 memberArray 의 길이보다 1 작은 값 까지 증가하기 때문에 
    
    memberArray의 값을 하나 하나 전부 꺼내올 수 있었다. console.log 에 i 값을 추가해서
    
    index 값도 같이 보일 수 있도록 할때는
    
    ```jsx
    var memberArray = ['egoing','graphitte','leezhe'];
    var i = 0;
    while(i < memberArray.length){
    	console.log(i, memberArray[i]);
    	i = i+1;
    }
    
    var meberObject = {
    	manager : 'egoing',
    	developer : 'graphitte',
    	designer : 'leezhce',
    }
    
    -------
    0
    "egoing"
    1
    "graphitte"
    2
    "lleezhe"
    ```
    
    console.group을 추가해 결과 값을 더 좋게 정리 가능하다. array loop 을 시작점과 끝점에 적어
    
    시작과 끝임을 알 수 있다.
    
    ```jsx
    var memberArray = ['egoing','graphitte','leezhe'];
    var i = 0;
    while(i < memberArray.length){
    	console.log(i, memberArray[i]);
    	i = i+1;
    }
    
    console.groupEnd('array loop');
    
    var meberObject = {
    	manager : 'egoing',
    	developer : 'graphitte',
    	designer : 'leezhce',
    }
    
    -------
    "array loop"
    0
    "egoing"
    1
    "graphitte"
    2
    "leezhe"
    "array loop"
    ```
    
    for반복문
    
    배열과 다른 for 반복문을 쓰게 될 것이다.
    
    자바스크립트 객체의 반복문에서 for 을 사용할 때에는 for-in을 사용한다.
    
    어렵게 생각할 것 없다.
    
    배열에서 for()에 배열이 들어간다면
    
    반복문은 원소의 이름이 들어갈 변수in(객체) 로 바꾸어 준다. 이후 중괄호{}에 들어가는
    
    코드가 실행된다. 객체에 있는 원소의 개수만큼 중괄호가 실행된다.
    
    ```jsx
    var memberArray = ['egoing', 'graphitte', 'leezhe'];
    
    var memberObject = {
    	manager : "egoing",
    	developer : "graphitte",
    	designer : "leezhe"
    }
    
    console.group('object loop');
    for (var name in memberObject){
    	console.log(name);
    }
    
    console.groupEnd('object loop');
    
    -----
    "object loop"
    "manager"
    "developer"
    "designer"
    "object loop"
    ```
    
    for 반복문을 사용해서 객체의 각 속성(객체가 가지고 있는 원소들) 도 출력할 수 있다.
    
    console.log(name,memberObject[name]); 으로 적으면 키 값의 value 와 key 값 출력 가능하다.
    
    ```jsx
    var memberArray = ['egoing', 'graphitte', 'leezhe'];
    
    var memberObject = {
    	manager : "egoing",
    	developer : "graphitte",
    	designer : "leezhe"
    }
    
    console.group('object loop');
    for (var name in memberObject){
    	console.log(name, memberObject[name]);
    }
    
    console.groupEnd('object loop');
    
    -----
    "object loop"
    "manager"
    "engoing"
    "developer"
    "graphitte"
    "designer"
    "leezhe"
    "object loop"
    ```
    
    그렇다면 왜 객체가 사용되게 되었을까? ⇒ 자바스크립트 객체가 쓰인 이유
    
    자바스크립트 애플리케이션에는 많은 수학적 개념을 사용하게 된다. 코드 또한 수학적 개념을
    
    사용할 수 있는 부분들이 이미 만들어져 있다. 
    
    만들어진 기능을 정리정돈하여 제공하기 위해 객체를 사용한다.
    
    객체에서 this 가 가지는 뜻
    
    this
    
    맨 처음 객체정의를 객체란 서로 연관된 변수와 함수를 붙어 이름을 붙이는 것 이라고 했다.
    
    메서드를 사용할 때 객체이름.메서드 로 쓰게 되면 만약 객체 이름이 바뀔 때 코드를 하나하나 바꾸어야 하는 불편함이 있었다. 이렇게 이미 알고 있는 코드를 어떻게 간편하게 사용할 수 있을까 하는 필요성이 생기는에 이를 this 를 통해 해결하는 것이다.
    
    메서드(함수) 가 있다면 자신이 속해있는 객체를 뜻하는 특수한 키워드가 있다.
    
     마치 사람이  “나는 /  저는” 이렇게 소개하는 의미처럼 말이다.
    
    이렇게 객체를 가리키도록 약속한 특수한 키워드가 this 이다.
    
    ```jsx
    var kim = {
    	name : 'kim',
    	second : '10',
    	sum : function(){
    		return this.first+this.second;
    	}
    }
    
    console.log("kim.sum(kim.first , kim.second)", kim.sum());
    
    --------
    "kim.sum(first , kim.second)"
    30
    ```
    
    이러한 객체의 constructor
    
    Constructor 는 생성자라고 불린다.
    
    함수를 일반적으로 그냥 호출하면 일반 함수로 역할을 하지만 앞에 new 라는 키워드를 붙이면
    
    생성자의 역할을 한다. 
    
    consturcot은 객체를 찍어내는 공장이라고 바라보면 쉽게 이해할 수 있다.
    
    생성자는 정말 놀라운 역할을 한다.
    
    자바스크립트에서는 시간을 알 수 있는 내장객체로 date 라는 함수가 있다.
    
    new 를 통해 date 객체를 생성해본다.
    
    ```jsx
    var di = new Date('2021-1-10');
    console.log('di.getFullYear()', di.getFullYear());
    
    ------
    "di.getFullYear()"
    2019
    ```
    
    이렇게 객체를 만드는 공장인 constructor(생성자) 가 있다면 원하는 값을 가지는 객체를 여러개
    
    만들 수 있다.
    
    date 함수처럼 객체를 찍어내는 공장을 만들어 보면 다음과 같다.
    
    ```jsx
    function person(){
    	this.name = 'kim'
    	this.first = 10;
    	this.second = 20;
    	this.third = 30;
    	this.sum = function(){
    		return this.first+this.second+this.third;
    	}
    }
    
    var kim = new person();
    
    var lee = new person()
    
    console.log("kim.sum()", kim.sum());
    console.log("lee,sum()", lee.sum());
    
    -----
    "kim.sum()"
    60
    "lee.sum()"
    60
    ```
    
    constructor function 을 만들게 되면 앞에 new 를 사용함으로써 실행될 떄마다 객체를 
    
    여러개 만들 수 있다. 또한 변수 내용도 마음대로 할 수 있다는 점은 자유롭게 만들 수 있다는
    
    장점이 있다는 것을 의미한다.
    
    만약 객체가 각각 다른 값을 갖게 하려면 함수 안의 ()괄호 안에 들어갈 변수를 넣어주면 된다.
    
    함수가 실행 될 떄 입력 값을 주도록 하여 객체 안의 값을 입력할 수도 있다.
    
    ```jsx
    function person(name, first, second, third){
    	this.name = name;
    	this.second = second;
    	this.third = third;
    	this.sum = function(){
    		return this.furst+this.second+this.third;
    	}
    }
    
    var kim = new person('kim', 10, 20, 30);
    
    var lee = new person('lee', 10, 10, 10);
    
    console.log("kim.sum()", kim.sum());
    console.log("lee.sum()", lee.sum());
    
    ---
    "kim.sum()"
    60
    "lee.sum()"
    30
    ```
    
- 1. 변수, 호이스팅, TDZ(Temporal Dead Zone)
    
    ■ 변수의 종류
    
    | var | let | const |
    | --- | --- | --- |
    
    var 은 한번 선언된 변수를 다시 선언할 수 있다.
    
    ```jsx
    var name = 'Mike';
    console.log(name); //Mike
    
    var name = 'Jane';
    console.log(name); //Jane
    ```
    
    <aside>
    💡 같은 상황에서 let 은 에러가 난다.
    
    </aside>
    
    또한 var 는 선언핮기 전에 사용할 수 있다.
    
    ```jsx
    console.log(name); //undefined
    
    var name = 'Mike'
    
    ---- 에러가 안난다. ----
    
    var name; // 이를 호이스팅(hoisting) 이라 한다.
    
    console.log(name);
    
    name = 'Mike'
    
    와 같은 의미이기 때문이다.
    ```
    
    ### 호이스팅
    
    스코프 내부 어디서든 변수 선언은 최상위에 선언된 것 처럼 행동함
    
    let 과 const 도 호이스팅이 안되는 것은 아니다.  그럼에도 에러가 난
    
    이유는 Temporal Dead Zone 때문이다.
    
    ■ 예
    
    console.log(name) // Temporal Dead Zone
    
    const name = 'Mike' // 함수 선언 및 할당
    
    console.log(name) // 사용 가능
    
    ■ 변수의 생성과정
    
    선언단계 ⇒ 초기화단계(undefined 를 할당 해주는 단계) ⇒ 할당단계
    
    | var | 선언 및 초기화 단계 ⇒ 할당단계 |
    | --- | --- |
    | let | 선언단계 ⇒ 초기화단계 ⇒ 할당단계 |
    | const | 선언단계+초기화단계+할당단계 동시에 |
    
    ```jsx
    let name;
    name = 'Mike';
    
    var age;
    age = 30;
    
    const gender;
    gender = 'Male';
    // const만 에러가 난다. const 선언때 할당을 안했기 때문
    ```
    
    ■ 스코프
    
    | var | 함수 스코프(function-scoped) |
    | --- | --- |
    | let, const | 블록 스코프(block-scoped) |
    
    블록스코프 : 함수, if문, for문, while 문, try/catch 문 등
    
    ```jsx
    function add(){
    	//block level scoped
    }
    
    if(){
    	//block level scoped
    }
    
    for(let i = 0; i < 10; i++){
    	//block level scoped
    }
    ```
    
    ■ 예
    
    if문 안에서 var로 선언된 변수는 if문 밖에서도 사용이 가능하다.
    
    ```jsx
    const age = 30;
    if(age > 19){
    	var txt = '성인'; //let. const 는 이 중괄호 안에서만 사용
    }
    
    console.log(txt); //성인
    ```
    

---

- 2. 생성자 함수
    
    개발을 하다보면 비슷한 객체를 여러개 만들 상황이 생긴다.
    
    회원이나 상품과 같은 경우에 생성자 함수를 사용한다.
    
    ■  객체 리터럴
    
    ```jsx
    let user = {
    	name : 'Mike',
    	age : 30,
    }
    ```
    
    ■  생성자 함수
    
    생상자 함수는 보통 첫글자를 대문자로 해서 함수를 만들어 준다.
    
    붕어빵 틀이나, 와플기를 생각하면 된다.
    
    필요한 재료를 넣고 찍어내는 것이다.
    
    ```jsx
    function User(name, age){ //첫글자를 대문자로!
    	this.name = name;
    	this.age = age;
    }
    
    let user1 = new User('Mike', 30);
    let user2 = new User('Jane', 22);
    let user3 = new User('Tom',17);
    
    // new 연산자를 사용해서 호출하고 있다.
    // 필요한 재료는 이름과 나이였다.
    ```
    
    function User(name, age){
    
    this = {}
    
    [this.name](http://this.name) = name;
    
    this.age = age;
    
    return this;
    
    }
    
    new 함수명;
    
    new 를 실행하는 순간 알고리즘으로 인해 주황 글씨가 자동으로 작동한다. 때문에 위의 코드에는 주황색 코드들이 없는 것 이다.
    
    이렇게 객체를 만들면 일일히 객체 리터럴을 만드는 것보다
    
    훨씬 빠르고 일관성 있게 객체를 만들 수 있다.
    
    ```jsx
    // 메소드를 추가해보기
    function User(name, age){
    	this.name = name;
    	this.age = age;
    	this.sayName = function(){
    		console.log(this.name);
    	}
    }
    
    let user5 = new User('Han', 40);
    user5.sayName(); //'Han'
    ```
    
    user5.sayName();  이 함수를 호출했을 때  sayName 함수의  this 는
    
    user5를 나타낸다.
    
    때문에 [this.name](http://this.name) 은 user5의 이름이 되는 것이다.
    
    ■ 예
    
    ```jsx
    //  생성자 함수 : 상품 객체를 생성해보기
    
    function Item(title, price){
    	//this = {};
    	this.title = title;
    	this.price = price;
    	this.showPrice = function(){
    		console.log(`가격은 ${price}원 입니다.`};
    	}
    
    //return this;
    }
    
    const item1 = new Item('인형', 3000);
    const item2 = new Item('가방', 4000);
    const item3 = new Item('지갑', 9000);
    
    console.log(item1, item2, item3);
    
    item3.showPrice();
    
    -----------------------------------
    Item {title: "인형", price: 3000, showPrice: f}
    Item {title: "가방", price: 4000, showPrice: f}
    Item {title: "지갑", price: 9000, showPrice: f}
    
    가격은 9000원 입니다.
    ```
    
    <aside>
    💡 생성자 함수는 잊지말고 new 를 붙여 주어야 한다.
    
    </aside>
    

---

- 3. 객체 메소드(Object Methods), 계산된 프로퍼티(Computed property)
    
    ■ Computed property
    
    ```jsx
    let a = 'age';
    
    const user = {
    	name : 'Mike',
    	age : 30  //age 대신 [a] 이렇게 사용해도 된다.
    	// 대괄호로 묶어주면 변수 a 에 할당된 값이 들어간다.
    }
    
    --------------------------------
    
    const user = {
    	[1 + 40] : 5,
    	["안녕" + :하세요"] : "Hello"
    }
    //는 아래와 같이 변경 할 수 있다.
    
    user
    {5 : 5, 안녕하세요: "Hello"}
    ```
    
    ■ 객체에서 사용 가능한 매서드들
    
    | Object.assign() | 객체 복제 |
    | --- | --- |
    | Object.keys() | 키 배열 반환 |
    | Object.values() | 값 배열 반환 |
    | Object.entries() | 키, 값 배열 반환 |
    | Object.fromEntries() | 키,값 배열을 객체로 (위랑 반대개념) |
    
    ### Object.assign() : 객체 복제
    
    ```jsx
    const user = {
    	name : 'Mike',
    	age : 30
    }
    
    const newUser = object.assign({}, user); //{} 는 초기값
    {} + { name : 'Mike', age : 30 } =
    {
    	name : 'Mike',
    	age : 30,
    }
    
    -------------------------------------------------
    //두개 이상의 객체 합치기
    
    const User = {
    	name : 'Mike'
    }
    
    const info1 = {
    	age : 30,
    }
    
    const info2 = {
    	gender : 'male',
    }
    
    Object.assign(user, info1, info2)
    ```
    
    ### Object.keys() : 키 배열 반환
    
    ```jsx
    const user = {
    	name : 'Mike',
    	age : 30,
    	gender : 'male',
    }
    
    Object.keys(user); // 로 입력하면 아래와 같이 반환된다.
    
    // ["name", "age", "gender"]
    ```
    
    ### Object.values() : 값 배열 반환
    
    ```jsx
    const user = {
    	name : 'Mike',
    	age : 30,
    	gender : 'male',
    }
    
    Object.values(user);  // 로 입력하면 아래와 같이 반환된다.
    
    // ["Mike", "30", "male"]
    ```
    
    ### Object.entries() : 키,값 배열 반환
    
    ```jsx
    const user = {
    	name : 'Mike',
    	age : 30,
    	gender : 'male',
    }
    
    Object.entries(user); // 로 입력하면 아래와 같이 반환된다.
    
    // 키와 값을 쌍으로 묶어서 벼열로 반환한다.
    // ["name", "Mike"], ["age", 30], ["gender", "male"]
    ```
    
    ### Object.fromEntries() : 키,값 배열을 객체로
    
    ```jsx
    const arr =
    [
    	["name", "Mike"],
    	["age", 30],
    	["gender", "male"]
    ];
    
    Object.fromEnteries(arr); // 로 입력하면 아래와 같이 반환된다.
    
    // { name : 'Mike', age : 30, gender : 'male', }
    ```
    
    ### ■ 예
    
    ```jsx
    // 기본예제
    let n = "name";
    let a = "age";
    
    const user = {
    	[n] : 'Mike',
    	[a] : 30,
    	[1 + 4] : 5, //계산식도 가능하다!
    }
    
    console.log(user);  // {name: "Mike", age:30, 5:5}
    
    ---------------------------------------------------------
    
    // 실용예제
    function makeObj(key, val){
    	return {
    		[key] : val
    	}
    }
    
    const obj = makeObj("나이", 33)
    
    console.log(obj); // {나이: 33}
    
    -----------------------------------
    
    // 복제
    const user = {
    	name : "Mike",
    	age : 30,
    };
    
    const user2 = Object.assign({}, user);
    user2.name = "Tom";
    
    console.log(user); //{name: "Mike", age:30}
    console.log(user2); //{name:"Tom", age:30}
    
    -----------------------------------
    
    //key값 찍기
    const user = {
    	name : "Mike",
    	age : 30,
    };
    
    const result = Object.key(user);
    
    console.log(result); //(2) ["name","age"]
    
    -----------------------------------
    
    //value값 찍기
    const user = {
    	name : "Mike",
    	age : 30,
    };
    
    const result = Object.values(user);
    
    console.log(result); //(2) ["Mike","30"]
    
    -----------------------------------
    
    // key, value 둘다 반환하고 싶을 때
    const user = {
    	name : "Mike",
    	age : 30,
    };
    
    const result = Object.entries(user);
    
    console.log(result); //(2) ["name","Mike"] , ["age",30]
    
    -----------------------------------
    // 반환을 역으로 객체로
    let arr = [
    	["mon","월"],
    	["tue","화"],
    ];
    
    const result = Object.fromEntries(arr);
    
    console.log(result); //{mon: "월", tue: "화"}
    ```
    

---

- 4. 심볼(Symbol)
    
    지금까지 객체 프로퍼티 키는 문자형으로 만들어 왔다.
    
    property key : 문자형
    
    ```jsx
    const obj = {
    	1: '1입니다.',
    	false: '거짓'
    }
    
    objet.keys(obj); //["1","false"]
    
    obj['1'] //"1 입니다."
    obj['false'] //"거짓"
    ```
    
    ### ■ Symbol : 유일한 식별자를 만들 때 사용한다.
    
    ```jsx
    const a = Symbol(); //new 를 붙이지 않는다.
    const b = Symbol();
    
    console.log(a) //Symbol()
    console.log(b) //Symbol()
    
    // 찍어보면 같게 나오는데 일치연산자로 확인해보면 false 가 나온다.
    ```
    
    심볼형은 **유일성**을 보장한다.
    
    ```jsx
    const id = Symbol('id');
    //심볼에 괄호로 설명을 붙여주면 디버깅할때 좋다. 심볼생성엔 영향x
    ```
    
    ### 심볼을 객체의 키로 사용해보기
    
    ```jsx
    //property key: 심볼형
    
    const id = Symbol('id);
    const user = {
    	name : 'Mike',
    	age : 30,
    	[id] : 'myid'
    }
    
    user // {name: "Mike", age: 30, Symbol(id): "myid"}
    user[id] // "myid"
    
    object.keys(user); // ["name", "age"] 만 나온다
    object.values(user); // ["Mike", "30"] 만 나온다
    object.enteries(user); // [Array(2), Array(2)] 만 나온다
    // 이러한 매소드들은 키가 심볼형인 프로퍼티는 건너뛴다.
    // 마찬가지로 for .. in 을 써도 마찬가지이다.
    for(let a in user){}
    ```
    
    <aside>
    💡 그렇다면 이렇게 숨겨진 Symbol 은 어떻게 쓸 수 있을까?
    
    </aside>
    
    특정데이터에 원본은 건드리지 않고 속성을 추가할 수 있다.
    
    ```jsx
    const user = {
    	name : 'Mike',
    	age : 30
    }
    
    const id = Symbol('id);
    user[id] = 'myid';
    
    user.name = 'myname'; // 다른사람이 미리만든거에 이런식으로 덮지말자
    ```
    
    심볼은 이름이 같더라도 모두 다른 존재이다.
    
    가끔 전역변수처럼 이름이 같으면 같은 객체를 가리켜야 할 때가 있다.
    
    이럴때 사용하는 것이 전역 심볼이다. **Symbol.for() : 전역심볼**
    
    ### Symbol.for() : 전역심볼
    
    하나의 심볼만 보장받을 수 있다.
    
    없으면 만들고 있으면 가져오기 때문이다.
    
    Symbol 함수는 매번 다른 Symbol 값을 생성하지만,
    
    Symbol.for 메소드는 하나를 생성한 뒤 키를 통해 같은 Symbol을 공유한다.
    
    ```jsx
    const id1 = Symbol.for('id');
    const id2 = Symbol.for('id');
    
    id1 === id2; //true 가 나온다. for 를 사용했기 때문이다.
    
    //이름을 얻고 싶다면?
    Symbol.keyFor(id1) // "id"
    ```
    
    <aside>
    💡 전역심볼이 아닌 것은 keyFor 을 사용할 수 없다.
    
    </aside>
    
    ```jsx
    // description
    
    const id = Symbol('id 입니다.');
    
    id.description; // "id 입니다."
    
    // 하지만 description 을 통해 이름을 알 수 있다.
    ```
    
    ### 숨겨진 Symbol key 보는 법
    
    ```jsx
    const id = Symbol('id');
    
    const user = {
    	name : 'Mike',
    	age : 30,
    	[id] : 'myid'
    }
    
    Object.getOwnPropertySymbols(user); // [Symbol(id)]
    Reflect.ownKeys(user) //심볼형을 포함한 모든 객체를 보여준다.
    // ["name","age",Symbol(id)]
    ```
    
    ### ■ 예제
    
    ```jsx
    //객체가 있고 객체 프로퍼티를 순회하며 메세지를 보여준다.
    
    //다른 개발자가 만들어 놓은 객체
    const user = {
    	name : "Mike",
    	age : 30,
    };
    
    // 내가 작업을 할 때
    //user.showName = function(){}; => 말도 안되는 소리가 출력됨
    const showName = Symbol('show name');
    user [showName] = function(){
    	console.log(this.name);
    };
    
    user[showName]();
    
    //사용자가 접속하면 보는 메세지
    for (let key in user){
    	console.log(`His ${key} is ${user[key]}.`);
    }
    ```
    
    <aside>
    💡 심볼은 다른사람이 만들어둔 프로퍼티를 덮을 일이 없다.
    
    </aside>
    

---

- 5. 숫자,수학 method(Number, Math)
    
    쇼핑몰이나 통계, 지표 등의 업무를 할 때 많이 사용하는 함수이다.
    
    ■ toString()
    
    10진수 ⇒ 2진수/16진수
    
    ```jsx
    let num = 10;
    
    num.toString(); //"10"
    // 괄호안에 숫자를 넣으면 그 숫자의 진법으로 변환을 한다.
    num.toString(2); //"1010" - 2진수로 나타낸 것이다.
    
    let num2 = 255;
    
    num2.toString(16); // <= 문자 255를 16진수로 바꾸어 보다.  "ff"
    ```
    
    ■ Math
    
    ```jsx
    Math.PI; //3.141592653589793
    
    Math.ceil() : 올림
    
    let num1 = 5.1;
    let num2 = 5.7;
    
    Math.ceil(num1); //6
    Math.ceil(num2); //6
    
    -----------------------
    
    Math.floor() : 내림
    
    let num1 = 5.1;
    let num2 = 5.7;
    
    Math.ceil(num1); //5
    Math.ceil(num2); //5
    
    -----------------------
    소수점 자릿수
    - 소수점 둘째자리 까지 표현(셋째 자리에서 반올림한다.)
    
    let userRate = 30.1234;
    
    Math.round(userRate * 100)/100 //30.12
    
    -----------------------
    소수점 자릿수 : toFixed()
    - 소수점 둘째자리 까지 표현(셋째 자리에서 반올림한다.)
    - 문자열을 반환하기때문에 넘버를 이용해 숫자로 작업해야 한다.
    
    let userRate = 30.1234;
    userRate.toFixed(2); //30.12
    userRate.toFixed(0); //30
    userRate.toFixed(6); //30.123400
    //반환 후 숫자로 작업하기
    
    Number(userRate.toFixed(2)); //30.12
    ```
    
    ■ isNaN()
    
    NaN이 맞는지 아닌지를 판단해줄 때 사용한다.
    
    ```jsx
    let x = Number('x'); //NaN
    
    x == NaN //false
    x === NaN //false
    NaN == NaN //flase
    // 자기자신과도 똑같지 않다고 판단한다. isNaN 만이 NaN이 아닌지 판단 가능
    
    isNaN(x) //true
    isNaN(3) //true 
    
    ```
    
    ■ parseInt()
    
    파스인트. L 아니고 i 이다.
    
    문자열을 숫자로 바꾸어 준다.
    
    ```jsx
    let margin = '10px';
    
    parseInt(margin); //10 문자가 혼용되어 있어도 동작을 한다.
    Number(margin); //NaN
    
    let redColor = 'f3''
    parseInt(redColor); //NaN 숫자로 시작하지 않으면 반환하지 않는다.
    
    ```
    
    ■ parseFloat()
    
    ```jsx
    let padding = '18.5%';
    
    parseInt(padding); //18
    parseFloat(padding); //18.5
    ```
    
    ■ Math.random()
    
    0~1 사이 무작위 숫자 생성
    
    ```jsx
    Math.random() //0.26027823967117425
    Math.random() //0.63185928941158114
    Math.random() //0.84544456758465655
    Math.random() //0.16165481321546541
    ...
    
    // 만약 1~100 사이 임의의 숫자를 뽑고 싶다면?
    
    Math.floor(Math.random()*100)+1
    
    // Math.random 으로 숫자를 생성한다. => 0.6789
    // 0.6789 에 100 을 곱한다. 1~100까지의 숫자중에서 뽑기를 원했기에 100을 곱한것
    // Math.floor 를 이용해서 소숫점 이하를 없앤다. 67.89 => 67
    // 67+1을 해준다. 그 이유는 랜덤숫자가 0 이 나올 수 있기 때문에 1을 더하는 것임.
    
    ```
    
    ■ Math.max() . Math.min()
    
    ```jsx
    Math.max(1, 4, -1, 5, 10, 9, 5.54); //10
    Math.min(1, 4, -1, 5, 10, 9, 5.54); //-1
    
    // 괄호안의 인수들 중 최댓값 최솟값을 구할 수 있다.
    ```
    
    ■ Math.abs()
    
    절대값을 구할 때 사용한다. absolute 의 약자이다.
    
    ```jsx
    Math.abs(-1) //1
    ```
    
    ■ Math.pow(n, m)
    
    거듭제곱의 값을 구할 때 사용한다. power 의 약자이다.
    
    ```jsx
    Math.pow(2, 10); //1024
    ```
    
    ■ Math.sqrt() 
    
    제곱근의 값을 구할 때 사용한다. squarerout 의 약자이다.
    
    ```jsx
    Math.sqrt(16); //4  루트 16 = 4
    ```
    

---

- 6. 문자열 메소드(String methods)
    
    ■  ‘ , “ , `
    
    큰 차이가 없다. 상황에 맞게 잘 사용하면 된다.
    
    ```jsx
    let hml = '<div class = "box_title">제목 영역</div>';
    //html의 영우는 큰따옴표가 있는 경우가 있어 ' ' 가 좋다.
    
    let desc = "It's 3 o'clock."
    //반면 영어로 된 문장은 큰 따옴표로 감싸는 것이 좋다.
    
    let name = 'Mike';
    let result = `My name is ${name}.` 
    let add = `2 더하기 3은 ${2+3}입니다.`
    //변수나 표현식을 넣어야 할 때는 백틱이 좋다.
    
    //백틱은 여러줄일때도 유용하게 사용된다.
    let desc = `오늘은 말고 화창한
    날씨가 계속 되겠습니다.
    내일은 비소식이 있습니다.`;
    
    //따옴표를 사용할 경우 \n 을 사용해야 하여 불편하다.
    let desc = '오늘은 맑고 화창한 \n 날씨가 계속 되겠습니다.';
    //꼭 한줄로 써야한다. 줄바꿈을 하면 에러가 발생하기 떄문이다.!
    let desc = '오늘은 맑고 화창한
    날씨가 계속 되겠습니다.
    내일은 비소식이 있습니다.'; //error!!!
    
    ```
    
    ■ length : 문자열 길이
    
    배열의 길이를 구할 때 length 를 사용했었다.
    
    ```jsx
    let desc = '안녕하세요.';
    
    //비밀번호를 몇자 이상 몇자 이하로 제안할때 사용한다.
    desc.length //6
    ```
    
    ■ 특정 위치에 접근할 경우
    
    ```jsx
    let desc = '안녕하세요.'; // 012345
    desc[2] // '하'
    
    //하지만 배열과 다르게 한글자만 바꾸는건 허용되지 않는다.
    desc[4] = '용';
    console.log(desc); //안녕하세요
    ```
    
    ■ 영어인 경우 toUpperCase() , toLowerCase() 로 대소문자 변경 가능
    
    - toUpperCase : 모든문자를 대문자로
    - toLowerCase : 모든 문자를 소문자로
    
    ```jsx
    let desc = "Hi guys. Nice to meet you.";
    
    desc.toUppercase(); //"HI GUYS. NICE TO MEET YOU."
    desc.toLowercase(); //"hi guys. nice to meet you."
    ```
    
    ■ indexOf 는 문자를 인수로 받아 몇번째에 위치하는지 알려준다.
    
    ```jsx
    let desc = "Hi guys. Nice to meet you.";
    desc.indexOf('to'); //14
    
    //찾는 내용이 없으면 -1 로 반환한다.
    desc.indexOf('man'); //-1
    
    //포함된 문자가 여러개 일지라도 첫번째 위치만 반환한다.
    // if 문 사용시 주의해야 한다.
    
    if(desc.indexOf('Hi')){
    	console.log('Hi 가 포함된 문장입니다.');
    } // 위의 문장은 console.log 메세지를 못본다.
    
    //Hi로 시작하는 문장이라 indexOf('Hi') 는 0 이기 때문.
    // if 에서 0 = false 이기 때문에 메세지를 못본다.
     
    if(desc.indexOf('Hi') > -1){
    	console.log('Hi 가 포함된 문장입니다.');
    }
    // -1 보다 큰가로 비교해야 한다.
    
    ---------------------------------------
    
    //금칙어 : 콜라
    function hasCola(str){
    	if(str.indexOf('콜라')){
    		console.log('금칙어가 있습니다.');
    	} else {
    		console.log('통과');
    	}
    }
    
    hasCola('와 사이다가 짱이야!'); //금칙어가 있습니다. > -1
    hasCola("무슨소리, 콜라가 최고"); //금칙어가 있습니다.
    hasCola("콜라"); //통과 > 0
    
    // 때문에 -1 을 추가해주어야 한다.
    
    function hasCola(str){
    	if(str.indexOf('콜라') > -1){
    		console.log('금칙어가 있습니다.');
    	} else {
    		console.log('통과');
    	}
    }
    
    hasCola('와 사이다가 짱이야!'); //통과
    hasCola("무슨소리, 콜라가 최고"); //금칙어가 있습니다.
    hasCola("콜라"); //금칙어가 있습니다.
    ```
    
    ■ str.slice(n,m) : 특정범위의 문자열만 뽑아보기.
    
    n : 시작점
    
    m : 없으면 문자열 끝까지 ...양수면 그 숫자전까지...음수면 끝에서부터 센다.
    
    ```jsx
    let desc = "abcdefg";
    
    desc.slice(2) // cdefg
    desc.slice(0,5) // abcde
    desc.slick(2,-2) // cde
    
    let list = [
    	"01. 들어가며",
    	"02. JS의 역사",
    	"03. 자료형",
    	"04. 함수",
    	"05. 배열",
    ];
    
    let newList = [];
    
    for(let i = 0; i < list.length; i++){
    	newList.push(
    		list[i].slice(4);
    	);
    }
    
    console.log(newList);
    
    // 들어가며, JS의 역사, 자료형, 함수, 배열
    ```
    
    !! 음수는 0 으로 인식한다.
    
    ■ str.substr(n,m) : n과 m 사이의 문자열을 반환. n,m을 바꿔도 동작
    
    ```jsx
    let desc = "abcdefg";
    
    desc.substring(2,5)//cde
    desc.substring(5,1)//cde
    ```
    
    ■ str.substr(n,m)
    
    n 부터 시작한다.
    
    m 은 까지가 아니라 개수이다.
    
    n 부터 시작해서 그 뒤에 몇개를 가져올 것인가?
    
    ```jsx
    let desc = "abcdefg";
    
    desc.substr(2,4) //cdef
    desc.substr(-4,2) //de
    ```
    
    ■ str.trim() : 앞 뒤 공백을 제거한다.
    
    ```jsx
    let desc = " coding                ";
    
    desc.trim(); //coding
    
    ```
    
    ■ str.repeat(n) : n번 반복시킨다.
    
    ```jsx
    let hello = "hello!";
    
    hello.repeat(3); // hello!hello!hello!
    ```
    
    ■ 문자열 비교
    
    ```jsx
    1 < 3 //true
    "a" < "c" //true
    ```
    
    ■ includes
    
    문자가 있으면 true
    
    문자가 없으면 false 반환
    
    !!굳이 인덱스 안쓰고 문자가 있는지 없는지만 판단한다.
    
    ```jsx
    //금칙어 : 콜라
    function hasCola(str){
    	if(str.includes('콜라')){
    		console.log('금칙어가 있습니다.');
    	} else {
    		console.log('통과');
    	}
    }
    
    hasCola('와 사이다가 짱이야!'); //통과
    hasCola("무슨소리, 콜라가 최고"); //금칙어가 있습니다.
    hasCola("콜라"); //금칙어가 있습니다.
    ```
    

---

- 7. 배열 메소드1(Array methods)
    
    ■ Array
    
    | push() | 뒤에 삽입 | unshift() | 앞에 삽입 |
    | --- | --- | --- | --- |
    | pop() | 뒤에 삭제 | shift() | 앞에 삭제 |
    
    ■ arr.splice(n,m)
    
    특정 요소를 지운다.
    
    n 번째 부터 시작해서 m 개를 지워라.
    
    ```jsx
    let arr = [1,2,3,4,5];
    arr.splice(1,2); //index 1 부터 시작해서 1포함2개 지워라.
    
    console.log(arr); //[1,4,5]
    ```
    
    ■ arr.splice(n,m,**x**):
    
    특정 요소를 지우고 추가한다.
    
    ```jsx
    let arr = [1,2,3,4,5];
    arr.splice(1,3,100,200);
    
    console.log(arr); // [1, 100, 200, 5]
    ```
    
    <aside>
    💡 index 1 부터 3개 지우고 그 사이에 100, 200 을 넣어라
    
    </aside>
    
    ```jsx
    let arr = ["나는","철수","입니다."];
    arr.splice(1,0,"대한민국","소방관")
    
    console.log(arr); // "나는" "대한민국" "소방관" "철수" "입니다."
    ```
    
    <aside>
    💡 index 1부터 시작해서 0개지우고 그 앞에 넣는다.
    
    </aside>
    
    또한! splice() 는 삭제된 요소를 반환한다.
    
    ```jsx
    let arr = [1,2,3,4,5];
    let result = arr.splice(1,2);
    
    console.log(arr); // [1,4,5]
    console.log(result); // [2,3]
    ```
    
    ■ arr.slice(n,m) : n부터 m 전까지 반환한다.
    
    ```jsx
    let arr = [1,2,3,4,5];
    arr.slice(1,4); //[2,3,4]
    
    //만약 아무것도 넣지 않는다면?
    let arr2 = arr.slice();
    console.log(arr2); //[1,2,3,4,5]  > 배열이 복사된다.
    ```
    
    ■ arr.concat(arr2, arr3, .....) : 합쳐서 새배열로 반환한다.
    
    ```jsx
    let arr = [1,2];
    
    arr.concat([3,4]); //[1,2,3,4]
    arr.concat([3,4],[5,6]); //[1,2,3,4,5,6]
    arr.concat([3,4],5,6); //[1,2,3,4,5,6]
    ```
    
    ■ arr.forEach(fn) : 배열반복
    
    지금까지의 배열의 반복은 for 문이나 forOf 문을 사용했다.
    
    forEach 로도 반복 가능하다.
    
    forEach 는 함수를 인수로 받아들인다. 그 함수는 세개의 매개변수가있다.
    
    하나는 **해당요소**이고 하나는 **인덱스** 이다. 마지막은 **해당배열 자체**
    
    | item | index | arr |
    | --- | --- | --- |
    | Mike | 0 | users |
    | Tom | 1 |  |
    | Jane | 2 |  |
    
    ```jsx
    let users = ['Mike','Tom','Jane'];
    
    user.forEach((item, index, arr) => {
    	//.........
    });
    ```
    
    ```jsx
    //forEach 문 예시
    
    let arr = ['Mike','Tom','Jane'];
    
    arr.forEach((name, index)=>{
    	console.log(name); //'Mike','Tom','Jane'
    	console.log(`${index + 1). ${name}`); //1. Mike, 2.Tom, 3. Jane
    });
    ```
    
    ■ arr.indexOf , arr.lastIndexOf
    
    ```jsx
    let arr = [1,2,3,4,5,1,2,3];
    
    arr.indexOf(3); //2 번째
    arr.indexOf(3,3); //7 > 두개일 경우 앞는 시작번째
    // 즉 index 3 부터 탐색해서 3이 있는 위치를 찾아라.
    // 3 4 5 1 2 3 > 마지막 3은 총 인덱스에서 7에 위치한다.
    
    arr.lastIndexOf(3); //7
    // 끝에서 첫번째로 만나는 3의 인덱스는 7번째에 위치해 있다.
    
    ```
    
    ■ arr.includes() : 포함하는지 확인 (인덱스 넘버가 안궁금할때)
    
    ```jsx
    let arr = [1,2,3]
    
    arr.includes(2); //true
    arr.includes(8); //false
    ```
    
    ■ arr.find(fn) , arr.findIndex(fn)
    
    찾는다는 의미는 동일하지만 보다 복잡한 작업이 가능하도록 함수를 반영
    
    짝수를 찾아낸다던지.. 성인을 찾는다던지 ...
    
    <aside>
    💡 첫번째 true 값만 반환하고 끝난다. 만약 없으면 undefined 반환
    
    </aside>
    
    ```jsx
    // find
    
    let arr = [1,2,3,4,5];
    
    const result = arr.find((item)=>{
    	return item % 2 === 0;
    });
    
    console.log(result); //짝수를 찾아서 반환한다. 2 or 4
    // 각 요소를 순회하며 12345에서 2를 나누었을때 0 이 나오는 수를 찾음
    
    // 객체가 들어간 배열은 indexOf 로는 찾기 힘들다.
    let userList = [
    	{ name: "Mike", age: 30 },
    	{ name: "Jane", age: 27 },
    	{ name: "Tom", age: 10 },
    ];
    
    const result = userList.find(user) => {
    	if(user.age < 19){
    		return true;
    	}
    	return false;
    });
    
    console.log(result); // {name:"Tom", age:10}
    
    -----------------------------
    
    //findIndex
    let userList = [
    	{ name: "Mike", age: 30 }, //0
    	{ name: "Jane", age: 27 }, //1
    	{ name: "Tom", age: 10 }, //2
    ];
    
    const result = userList.findIndex(user) => {
    	if(user.age < 19){
    		return true;
    	}
    	return false;
    });
    
    console.log(result); // 2
    
    //주의할 점은 첫번째 트루값만 반환하고 끝난다.
    //만약 없으면 undefined 를반환한다.
    ```
    
     ■ arr.filter(fn) : 만족하는 모든 요소를 배열로 반환
    
    find 는 딱 하나만 찾았다.
    
    조건을 만족하는 모든함수를 찾고자 할 때 filter 를 사용한다.
    
    ```jsx
    let arr = [1,2,3,4,5,6];
    
    const result = arr.filter((item)=>{
    	return item % 2 === 0;
    });
    
    console.log(result); //(3) [2,4,6]
    ```
    
    ■ arr.reverse() : 역순으로 재정렬
    
    최근 가입된 유저부터 보여준다거나, 게시판에 최근작성된 글순서에 사용
    
    ```jsx
    let arr = [1,2,3,4,5];
    
    arr.reverse(); //[5,4,3,2,1]
    ```
    
    ■ arr.map(fn)
    
    함수를 받아 특정 기능을 시행하고 새로운 배열을 반환한다.
    
    실무에서 매우매우 많이 사용한다.
    
    ```jsx
    let userList = [
    	{ name: "Mike", age: 30 }, //0
    	{ name: "Jane", age: 27 }, //1
    	{ name: "Tom", age: 10 }, //2
    ];
    
    // 매번 찾기가 귀찮아서 성인 이라는 함수를 추가해본 사례
    
    let newUserList = userList.map(user, index)=>{
    	return Object.assign({}, user, {
    		id: index + 1,
    		isAdult: user.age > 19,
    	})
    });
    
    console.log(newUserList);
    
    //0: { name: "Mike", age: 30, id: 1, isAdult: true }
    //1: { name: "Jane", age: 27, id: 2, isAdult: true }
    //2: { name: "Tom", age: 10, id: 3, isAdult: flase }
    //length: 3
    
    console.log(userList); //기존의 유저리스트는 변경된 것 없다.
    //0: { name: "Mike", age: 30 }
    //1: { name: "Jane", age: 27 }
    //2: { name: "Tom", age: 10 }
    //length: 3
    ```
    
    ■ arr.join
    
    배열을 합쳐서 문자열을 만들 때
    
    ```jsx
    let arr = ["안녕","나는","철수야"]
    let result = arr.join();
    let result2 = arr.join(" ");
    let result3 = arr.join("-");
    
    console.log(result); // 안녕,나는,철수야
    console.log(result2); // 안녕 나는 철수야
    console.log(result3); // 안녕-나는-철수야
    
    ```
    
    ■ arr.split
    
    문자열을 나눠서 배열로 만들 때
    
    ```jsx
    const users = "Mike,Jane,Tom,Tony";
    const result = users.split(","); // 어떤기준(,)으로 나눌거냐?
    
    console.log(result); //["Mike","Jane","Tom","Tony"]
    
    // 만약 split()에 아무것도 입력하지 않는다면?
    let str = "Hello, My name is Mike.";
    const result = str.split("");
    
    console.log(result);
    // ["H","e","l","l","o"," ","M", ... "M","i","k","e","."]
    ```
    
    ■ Array.isArray()
    
    배열인지 아닌지를 확인하기 위해 사용한다.
    
    자바스크립트에서 배열은 객체형에 속한다.
    
    때문에 타입오브는 객체라고 알려준다.
    
    **일반객체와 구분이 불가능하다.**
    
    ```jsx
    let user = {
    	name: "Mike",
    	age: 30,
    }; //일반적인 객체
    
    let userList = ["Mike","Tom","Jane"]; //배열
    
    console.log(typeof user); //object
    console.log(typeof userList);  //object
    
    console.log(Array.isArray(user)); //false
    console.log(Array.isArray(userList)); //true
    ```
    

---

- 8. 배열 메소드2(sort, reduce)
    
    ■ arr.sort()
    
    배열을 재정렬
    
    배열 자체가 변경되므로 주의를 하여야 한다.
    
    인수로 정렬 로직을 담은 함수를 받음
    
    ```jsx
    let arr = [1,5,4,2,3];
    arr.sort();
    
    console.log(arr); // (5)[1,2,3,4,5]
    
    let arr1 = ['a','c','d','e','b']
    arr.sort();
    
    console.log(arr1); // (5)["a","b","c","d","e"]
    
    // 십의 자리수는..?
    let arr = [27,8,5,13];
    arr.sort();
    
    console.log(arr); // (4)[13,2,5,8]
    
    // why..? 정렬할 때 요소를 문자열로 취급하기 때문이다. 
    // 값을 비교해 줄 수 있는 함수를 전달하여야 제대로 나온다.
    // sort 는 함수를 인수로 받는다.
    
    let arr = [27,8,5,13]; 
    
    arr.sort((a,b) => {
    	console.log(a, b);
    	// 콘솔로 a b 를 열어보면 8 27, 5 8, 13 5, 13 8, 13 27
    	// 이렇게 나온다.
    	// 8, 27, 5, 13
    	// 5, 8, 27, 13
    	// 5, 8, 13, 27 이러한 비교를 통해 결과값이 나오는 것.
    	return a - b;
    }); 
    
    두 요소를 전달하고 크기를 비교해서 양수인지 0 인지 음수인지
    만알려주면 된다.
    a 가 b 보다 크면 양수를 return 할 것이고
    a 와 b 가 같으면 0
    a 가 b 보다 작으면 음수를 return 할 것이다.
    
    console.log(arr); // (4)[5,8,13,27]
    ```
    
    <aside>
    💡 이런 함수가 어려워서 Lodash 라는 라이브러리를 사용한다.
    
    </aside>
    
    ■ Lodash
    
    _.sortBy(arr); 을 통해 바로 숫자 문자 객체를 원하는 기준으로 정렬한다.
    
    [http://lodash.com/](http://lodash.com/) 에서 확인하기.
    
    ■ arr.reduce()
    
    인수로 함수를 받는다.
    
    (누적 계산값[prev], 현재값[cur]) ⇒ {return 계산값};
    
    ```jsx
    // 배열의 모든 수 합치기
    let arr = [1,2,3,4,5]; // 이전에 for, for of, forEach 등을 썼다.
    
    let result = 0; 
    arr.forEach(num => {
    	result += num;
    }); //초기값을 0 을 주면서 1이 더해지고 2가 더해지고 ... 5까지 더함
    
    console.log(result); //15
    
    이런 작업들을 한번에 해주는게 reduce 이다.
    
    const result = arr.reduce((prev, cur)=>{
    	return prev + cur;
    }, 0) //초기값에 0 을 준 것이다. 
    
    // 초기값이 0 이라 누적값이 0 이다.
    // 거기에 현재값 1을 더하고 한바퀴 돈다. 누산값 1
    // 1인 상태에서 2가 들어온다. 누산값 3
    // 3인 상태에서 3이 들어온다. 누산값 6
    // .... 결과적으로 15가 나오게 됨. 
    
    console.log(result); 15
    
    }, 0) 이부분에서 0 을 100 으로 바꾼다면?
    115 가 나온다.
    
    // map 이나 filter 대신에 reduce 를 써서 배열을 반환해보자
    
    // 성인만 뽑아서 배열을 완성시켜 보자.
    let userList = [
    	{ name: "Mike", age:30 },
    	{ name: "Tom", age:10 },
    	{ name: "Jane", age:27 },
    	{ name: "Sue", age:26 },
    	{ name: "Harry", age:42 },
    	{ name: "Steve", age:60 },
    ];
    
    let result = userList.reduce((prev, cur)=>{
    	if(cur.age > 19){ 
    		prev.push(cur.name);
    	}
    }[]); // 초기값은 빈 배열로
    
    // 만약에 19살보다 나이가 크다면 배열에 푸쉬해서 넣어주고 리턴
    // 누산값: ["Mike"]
    // Tom 은 더 어리니깐 패스하고 다시 리턴
    // Jane은 더 많으니깐 배열에 푸쉬해주고 다시 리턴 ..... 반복
    
    console.log(result);
    // ["Mike","Jane","Sue","Harry","Steve"] length:5 
    
    // 나이의 합을 구하려면 어떻게 하면 될까?
    let userList = [
    	{ name: "Mike", age:30 },
    	{ name: "Tom", age:10 },
    	{ name: "Jane", age:27 },
    	{ name: "Sue", age:26 },
    	{ name: "Harry", age:42 },
    	{ name: "Steve", age:60 },
    ];
    
    let result = userList.reduce((prev, cur)=>{
    	return(prev += cur.age);
    }, 0);
    
    console.log(result); //196
    
    //이름의 길이가 3자인 사람들만 찾으면?
    let userList = [
    	{ name: "Mike", age:30 },
    	{ name: "Tom", age:10 },
    	{ name: "Jane", age:27 },
    	{ name: "Sue", age:26 },
    	{ name: "Harry", age:42 },
    	{ name: "Steve", age:60 },
    ];
    
    let result = userList.reduce((prev, cur)=>{
    	if(cur.name.length === 3){
    		prev.push(cur.name);
    	}
    	return prev;
    }, []);
    
    console.log(result); // (2) ["Tom","Sue"]
    
    ```
    
    ■ arr.reduceRight()
    
    arr.reduce 와 기능은 동일하다. 다만 배열 우측부터 연산을 수행한다.
    
    <aside>
    💡 각 상황에 맞는 매서드를 사용하는건 개인의 능력이다.
    
    </aside>
    

---

- 9. 구조 분해 할당(Destructuring assignment)
    
    배열이나 객체의 속성을 분해해서 그 값을 변수에 담을 수 있게 하는 표현식
    
    ■ 배열 구조 분해
    
    ```jsx
    let [x, y] = [1, 2];
    
    console.log(x); // 1
    console.log(y); // 2
    
    --------------------------------------
    
    let users = ['Mike','Tom','Jane'];
    let [user1, user2, user3] = users;
    
    위의 let[user1, user2, user3] = users; 의 의미는
    let user1 = users[0];
    let user2 = users[1];
    let user3 = users[2];
    와 같다.
    
    console.log(user1); //'Mike'
    console.log(user2); //'Tom'
    console.log(user3); //'Jane'
    
    --------------------------------------
    
    let str = "Mike-Tom-Jane";
    let [user1, user2, user3] = str.split('-');
    스플릿(-)로 자르면 ["Mike","Tom","Jane"] 이 된다.
    
    console.log(user1); //'Mike'
    console.log(user2); //'Tom'
    console.log(user3); //'Jane'
    
    --------------------------------------
    
    // 해당하는 값이 없다면..? 기본값에 대한 이해.
    let [a,b,c] = [1,2]; // c 가 없네 ..? 이러면 undefined 가 나옴
    
    이럴때 기본값을 주면 error 를 미연에 방지 가능하다.
    
    let [a=3, b=4, c=5] = [1,2]; //기본값은 3,4,5 를 의미함.
    // 만약 값이 undefined가 나오면 기본값을 그대로 사용하게 되는 것.
    
    console.log(a); //1
    console.log(b); //2
    console.log(c); //5 처음에 할당이 없어 undefined가 나와서 기본값
    
    --------------------------------------
    
    // 일부 반환값을 무시하는 경우
    let [user1, ,user2] = ['Mike','Tom','Jane','Tony'];
    
    console.log(user1); //'Mike'
    console.log(user2); //'jane'
    // Tom 과 Tony 는 무시가 된 것이다.
    
    --------------------------------------
    // 이미 할당된 변수를 바꾸려면
    let a = 1;
    let b = 2;
    
    [a, b] = [b, a];
    ```
    
    ■ 객체 구조 분해
    
    ```jsx
    let user = {name: 'Mike', age:30};
    let {age, name} = user;
    
    여기서 let {name, age} = user; 코드는
    let name = user.name;
    let age = user.age;
    와 같다.
    
    console.log(name); //'Mike'
    consoel.log(age); //30
    
    !!배열구조분해와의 차이점은 순서를 신경쓰지 않아도 된다는 것이다.
    
    --------------------------------------
    
    // 새로운 변수 이름으로 할당할 경우
    let user = {name: 'Mike', age: 30};
    
    let {name, age} = user; 굳이 이렇게 안쓰고
    let {name: userName, age: userAge} = user; 이렇게 해도 된다.
    
    console.log(userName); // 'Mike'
    console.log(userAge); //'30'
    
    --------------------------------------
    
    //객체를 분해할 때에도 기본값을 줄 수 있다.
    let user = {name: 'Mike', age: 30};
    let {name, age, gender} = user; //gender = undefined 가 나온다.
    
    let {name, age, gender = 'male'} = user; 
    // 기본값 male 을 주면 값이 없을 때 male 을 반환한다.
    
    let user = {
    	name: 'Jane',
    	age: 18,
    	gender: 'female'
    }; //이렇게 gender 에 female 이라는 값이 있을 경우
    
    console.log(gender); // 'female' 을 반환한다.
    ```
    

---

- 10. 나머지 매개변수, 전개 구문(Rest parameters, Spread syntax)
    
    ... (점 세개) 로 사용한다.
    
    ■ 인수 전달
    
    ```jsx
    function showName(name){
    	console.log(name);
    }
    
    showName('Mike'); //'Mike'
    // 여기서 만약 이름을 하나 더 전달하게 된다면?
    showName('Mike','Tom'); // error 는 안나지만 Mike 만 찍힌다.
    
    자바스크립트에서 함수에 전해주는 인수에는 개수 제한이 없기 때문이다.
    인수의 개수를 정해놓고 함수를 만들어도 실호출시 그 갯수를 정확히
    맞출 필요는 없다.
    심지어
    showName(); 
    이렇게 아무것도 적지 않아도 에러는 발생하지 않는다. undefined는 뜸
    ```
    
    함수의 인수를 얻는 방법은 두가지 가 있다.
    
    **arguments** 로 접근하거나, **나머지매개변수를** 사용하는 것이다.
    
    과거에는 arguments 만 사용 가능했다.!
    
    지금은 장점이 많은 나머지매개변수를 활용한다.
    
    참고로 arrow 함수에는 arguments 가 없다.
    
    ■ arguments
    
    함수로 넘어 온 모든 인수에 접근한다.
    
    함수내에서 이용 가능한 지역 변수
    
    lengh , index 가 있어 배열이라 생각할 수 있지만
    
    Array 형태의 객체 이다. Array 형태는 length, index등 속성을 가지지만
    
    배열의 내장 메서드가 없다.(forEach , map 같은 것은 사용 불가) 
    
    ```jsx
    function showName(name){
    	console.log(arguments.length);
    	console.log(arguments[0]);
    	console.log(arguments[1]);
    }
    
    showName('Mike', 'Tom');
    //2
    //'Mike'
    //'Tom'
    ```
    
    <aside>
    💡 es6를 사용할 수 있는 한경이면 가능한 나머지매개변수 사용을 권장
    
    </aside>
    
    ■ 나머지 매개변수(Rest parameters)
    
    ```jsx
    function showName(...names){
    	console.log(names);
    }
    
    showName(); // [] > 아무것도 없으면 빈배열이 나온다.
    showName('Mike'); // ['Mike']
    showName('Mike','Tom'); //['Mike','Tom']
    ```
    
    **점 세개**를 찍고 **뒤에 배열이름**을 정해준다.
    
    그러면 names 배열 안에 전달된 인수들이 들어간다.
    
    ```jsx
    // 전달 받은 모든 수를 더해야 할때
    add(1,2,3);
    add(1,2,3,4,5,6,7,8,9,10);
    와 같이 매번 전달하는 숫자가 다르다고 가정하고 코드를 짜는 것임.
    
    function add(...numbers){
    	let result = 0;
    	number.forEach((num) => (result += num));
    	console.log(result); // 6, 55
    }
    
    add(1,2,3); //6
    add(1,2,3,4,5,6,7,8,9,10); //55
    ```
    
    numbers 는 배열이고 length가 있기 때문에 forEach 뿐만 아니라
    
    for 문으로 사용가능하다.
    
    arguments 와 다르게 배열의 매서드들도 사용 가능하다.
    
    number.**forEach** 처럼!!
    
    ```jsx
    function add(...numbers){
    	let result = numbers.reduce((prev, cur) => pre + cur);
    	console.log(result); //6 , 55
    }
    
    add(1,2,3); //6
    add(1,2,3,4,5,6,7,8,9,10); //55
    ```
    
    ■ 유저 객체를 만들어주는 생성자 함수를 만들어보기
    
    !! 생성자 함수는 첫글자는 대문자로!!
    
    ```jsx
    function User(name, age, ...skills){ // 사람마다 스킬개수는 다르다
    	this.name = name;
    	this.age = age;
    	this.skills = skills;
    }
    
    const user1 = new User('Mike', 30, 'html', 'css');
    const user2 = new User('Tom', 20, 'JS', 'React');
    const user3 = new User('Jane', 10, 'English');
    
    console.log(user1); // User{name:"Mike",age:30,skills:Array(2)}
    console.log(user2); // User{name:"Tom",age:20,skills:Array(2)}
    console.log(user3); // User{name:"Jane",age:10,skills:Array(1)}
    ```
    
    <aside>
    💡 나머지 변수는 항상 마지막에 위치하여야 한다.
    
    </aside>
    
    ■ 전개 구문(Spread syntax) : 배열
    
    ```jsx
    let arr1 = [1,2,3];
    let arr2 = [4,5,6];
    
    let result = [0, ...arr1, ...arr2, 7, 8, 9];
    
    ...arr1 = 1,2,3 을 풀어서 쓴거다.
    ...arr2 = 4,5,6 을 풀어서 쓴 것이다.
    
    console.log(result); //[0,1,2,3,4,5,6,7,8,9]
    
    이것을 배우기 전에는
    arr.push(), arr.splice(), arr.concat() 처럼 복잡하게 했었 다...
    ```
    
    ■ 전개 구문(Spread syntax) : 객체
    
    ```jsx
    let user = {name:'Mike'}
    let mike = {...user, age:30}
    
    console.log(mike) //{name: "Mike", age:30}
    ```
    
    <aside>
    💡 Object.assign 을 쓸 필요가 없어진다!
    
    </aside>
    
    ■ 전개 구문(Spread syntax) : 복제
    
    ```jsx
    let arr = [1,2,3];
    let arr2 = [...arr]; //[1,2,3]
    
    let user = {name:'Mike', age:30};
    let user2 = {...user};
    
    user2.name = "Tom";
    
    console.log(user.name); // "Mike"
    console.log(user2.name); //"Tom"
    
    --------------------------------------
    
    ★ Not 전개구문
    arr1을 [4,5,6,1,2,3] 으로 바꾸려면 어떻게 할까?
    
    let arr1 = [1,2,3];
    let arr2 = [4,5,6];
    
    arr2 를 루프를 돌면서 거기에 arr1 을 넣어주면 된다.
    
    arr2.forEach(num => {
    	arr1.unshift(num); // (6) [6,5,4,1,2,3] 이 나온다... 왜 ...?
    });
    
    console.log(arr1);
    
    arr2를 돌면서 4가 넘어오는데 4를 1앞에 넣어주고 있다.
    5를 4 앞에 또 넣고 6을 4앞에 넣고 이렇기 때문에 저런식으로 나왔다.
    
    let arr1 = [1,2,3];
    let arr2 = [4,5,6];
    
    arr2.reverse().forEach(num => {
    	arr1.unshift(num);
    });
    
    console.log(arr1); // (6) [4,5,6,1,2,3]
    
    reverse()를 넣어 4,5,6 을 6,5,4 로 만들어주고 진행 해야 한다.
    
    --------------------------------------
    
    !!!!!!!전개구문으로 해보면?!!!!!!!
    
    let arr1 = [1,2,3];
    let arr2 = [4,5,6];
    
    arr1 = [...arr2, ...arr1];
    
    console.log(arr1); // (6) [4,5,6,1,2,3]
    
    --------------------------------------
    
    !!!객체에서도 사용해보자!!!!
    
    let user = { name: "Mike" };
    let info = { age: 30 };
    let fe = { "JS", "React" };
    let lang = {"Korean","English"};
    
    console.log(user);
    
    유저에 인포를 넣어야 하고 프론트앤드 기술과 언어를 스킬로 만들어서
    넣어야 한다면?
    
    ★ Not 전개구문
    
    let user = { name: "Mike" };
    let info = { age: 30 };
    let fe = { "JS", "React" };
    let lang = {"Korean","English"};
    
    user = Object.assign({},
    	user,
    	info,
    	{
    		skills : []
    	});
    
    fe.forEach((item => {
    	user.skills.push(item);
    });
    lang.forEach((item) => {
    	user.skills.push(item);
    });
    
    console.log(user);
    
    --------------------------------------
    
    !!!!!!!전개구문으로 해보면?!!!!!!!
    
    let user = { name: "Mike" };
    let info = { age: 30 };
    let fe = { "JS", "React" };
    let lang = {"Korean","English"};
    
    user = {
    	...user,
    	...info,
    	skills: [...fe, ...lang],
    };
    
    console.log(user);
    ```
    

---

- 11. 스코프(Scope), 클로저(Closure)
    
    스코프란 자바스크립트를 포함한
    
    모든 프로그래밍 언어에서 가장 기본적이면서 중요한 개념이다.
    
    ```jsx
    function add(x,y){
    	console.log(x,y);
    	return x + y;
    }
    
    add(3,6);
    
    console.log(x,y)
    ```
    
    코드 속 2개의 콘솔에는 어떤 값들이 찍힐까?
    
    add 가 하나 선언이 되었고 밑에 add가 호출이 되었군!
    
    x에 3이 들어가고 y에 6이 들어가서
    
    첫번째 콘솔은 3이랑 6이 찍히고
    
    두번째 콘솔은 에러가 나지 않을까?
    
    >> 정답
    
    각각의 변수는 자신이 선언된 위치에 따라 본인의 유효 범위가 결정되었다.
    
    변수 x와 y에 대해 다른코드가 참조할 수 있는 어떠한 범위가 결정된것이다.
    
    ```jsx
    function add(x,y){
    	console.log(x,y); //3,6
    	return x + y;
    }
    
    add(3,6);
    
    console.log(x,y) //error
    ```
    
    이러한 유효범위를 스코프 라고 한다.
    
    ■ 스코프
    
    변수이름, 함수이름, 클래스이름 과 같은 **식별자**가
    
    **본인이 선언된 위치에 따라 다른 코드에서** 자신이 참조될 수 있을지 
    
    없을지 결정 되는 것.
    
    ```jsx
    var x = "나는 전역 x 야";
    
    function outer(){
    	var y = "나는 outer 함수의 지역 y 야";
    	console.log(x); //나는 전역 x 야
    	console.log(y); //나는 outer 함수의 지역 y 야
    
    	function inner(){
    		var x = "나는 inner 함수의 지역 x 야";
    		console.log(x); //나는 inner 함수의 지역 x 야
    		console.log(y); //나는 outer 함수의 지역 y 야
    	}
    
    	inner();
    }
    
    outer();
    console.log(x); //나는 전역 x 야
    console.log(y); //ReferenceError 어쩌고저쩌고
    
    // outer 함수의 스코프 = function outer(){var y ~ inner();}
    // inner 함수의 스포크 = function inner(){}
    ```
    
    위의 내용을 구조형으로 다시 볼때
    
    전역스코프
    
    x : 나는 전역 x 야
    
    outer: <function object>
    
    △
    
    outer 지역 스코프
    
    y : 나는 outer 함수의 지역 y 야
    
    inner: <function object>
    
    △
    
    inner 지역 스코프
    
    x : 나는 inner 함수의 지역 x 야
    
    ※ 이러한 구조를 스코프 체인이라 하며 물리적으로 구현되어 있다.
    
    또한 스코프는 **블록레벨스코프**(if문, for문, 함수 ...) 과 **함수레벨스코프**(only 함수)로 나눌 수 있다.
    
    | 블록레벨 | 대부분의 프로그래밍 언어 |
    | --- | --- |
    | 함수레벨 | javascript |
    
    <aside>
    💡 javascript 도 블록레벨 스코프를 활용하고 싶어 만든게 **let** 과 **const** 이다.
    
    </aside>
    
    스코프는 상위스코프가 결정되는 시점을 기준으로 
    
    함수가 호출된 시점에서 결정되는 것을 **동적스코프**
    
    함수가 정의된 시점에서 결정되는 것을 **정적스코프**(**렉시컬스코프**)라고 한다.
    
    자바스크립트에서 함수는 태어나면 본인의 내부슬롯에 상위스코프에 대한 참조를 저장한다.
    
    함수 호출
    
    ▽
    
    실행 컨텍스트 생성 > push > 실행컨텍스트 스택 생성
    
    ▽
    
    렉시컬 환경 생성 (포함하는 식별자, 식별자에 바인딩 된 값, 상위 렉시컬 환경에 대한 참조)
    
    ▽
    
    코드실행이 끝나면 실행컨텍스트에서 해당 컨텍스트를 팝하여 제거함
    

---

- 12.  setTimeout , setInterval
    
    **setTimeout** : 일정 시간이 지난 후 함수를 실행
    
    ```jsx
    // 3초 뒤에 로그를 띄워준다.
    function fn(){
    	console.log(3)
    }
    
    setTimeout(fn, 3000); //setTimeout( 실행할 함수명 . 시간 )
    
    ----------- 같은 식 -----------
    
    setTimeout(function(){
    	console.log(3)
    }, 3000)
    
    ----------- 같은 식 -----------
    
    function showName(name){
    	console.log(name);
    }
    
    setTimeout(showName, 3000, 'Mike');
    
    스케줄링을 취소하고 싶을땐
    
    const tId = funciont showName(name){~} 
    
    clearTimeout(tId);
    ```
    
    **setInterval** : 일정 시간 간격으로 함수를 반복 (setTimeout 과 사용법이 동일하다.)
    
    ```jsx
    function showName(name){
    	console.log(name);
    }
    
    const tId = setInterval(showName, 3000, 'Mike');
    
    // 3초 간격으로 마이크가 찍힌다. 중간에 중단하려면..?
    
    clearInterval(tId); 를 해주면 된다.
    ```
    
    주의사항
    
    ```jsx
    delay = 0 //딜레이를 0 으로 주어도 바로 실행되지는 않는다.
    
    setTimeout(function(){
    	console.log(2); //그 다음에 실행됨
    }, 0);
    
    console.log(1); //먼저실행됨
    
    // 이유는 일반 함수 먼저 실행되고 그 뒤에 스케쥴 함수가 실행되기 때문이다.
    
    ```
    
    예
    
    ```jsx
    //유저가 얼마나 접속을 했을까?
    
    let num = 0;
    
    function showTime(){
    	console.log(`안녕하세요. 접속하신지 ${num++}초가 지났습니다.`);
    	if(num > 5){
    		clearInterval(tId);
    	}
    }
    
    const tId = setInterval(showTime, 1000);
    
    // 안녕하세요 접속하신지 0초 ~ 5초까지만 나오고 스탑
    ```
    

---

- 13. (call , apply , bind)
    
    자바스크립트에서는 함수 호출 방식과 관계없이  this 를 지정할 수 있다.
    
    ■ call
    
    call 메서드는 모든 함수에서 사용 가능하며, this 를 특정값으로 지정할 수 있다.
    
    ```jsx
    const mike = {
    	name: "Mike",
    };
    
    const tom = {
    	name: "Tom",
    };
    
    function showThisName(){
    	console.log(this.name);
    }
    
    showThisName(); // 이건 윈도우를 나타내기 때문에 아무것도 안나온다.
    showThisName.call(mike); //"Mike"
    
    function update(birthYear, occupation){
    	this.birthYear = birtYear;
    	this.occupation = occupation;
    }
    
    update.call(mike, 1999, "singer");
    console.log(mike);
    
    = 객체 정보 업데이트를 가능하게 해준다.
    ```
    
    ■ apply
    
    apply는 함수 매개변수를 처리하는 방법을 제외하면 call과 완전히 같다.
    
    call 은 일반적인 함수와 마찬가지로 매개변수를 직접 받지만, apply는 매개변수를 배열로 받음!
    
    ```jsx
    const mike = {
    	name: "Mike",
    };
    
    const tom = {
    	name: "Tom",
    };
    
    function showThisName(){
    	console.log(this.name);
    }
    
    showThisName(); // 이건 윈도우를 나타내기 때문에 아무것도 안나온다.
    showThisName.call(mike); //"Mike"
    
    function update(birthYear, occupation){
    	this.birthYear = birtYear;
    	this.occupation = occupation;
    }
    
    update.apply(mike, [1999, "singer"]); //매개변수를 배열로 묶어주기!
    console.log(mike);
    ```
    
    ■ bind
    
    함수의 this 값을 영구히 바꿀때 사용한다.
    
    ```jsx
    const mike = {
    	name: "Mike",
    };
    
    function update(birthYear, occupation){
    	this.birthYear = birtYear;
    	this.occupation = occupation;
    }
    
    const updateMike = update.bind(mike);
    
    updateMike(1980, "police");
    console.log(mike);
    
    ------ 실사례 ------
    
    const user = {
    	name: "Mike";
    	showName: function(){
    		console.log(`hello, ${this.name}`);
    	},
    };
    
    user.showName();
    
    let fn = user.showName;
    
    fn(); // hello > fn 을 할당할 때 this 을 잃었기 때문이다.
    fn.call(user); // hello, Mike
    fn.apply(user); // hello, Mike
    
    let boundFn = fn.bind(user);
    
    boundFn(); // hello, Mike
    ```
    

---

- 14. 상속, 프로토타입()
    
    Prototype : 프로토타입. 번역시 원형(사물 본래의 모습)
    
    Javascript = ptrototype base language (프로토타입 기반 언어)
    
    자바스크립트에서 프로토타입이 주는 의미는
    
    중급에서 고급으로 넘어가는 길목에 있다. 중요하다.
    
    생성자 함수에서는 새 객체가 생성될 때 sum 이라는
    
    내부메서드가 새롭게 생성되어야 한다.
    
    그만큼 생성될때마다 메모리 낭비가 발생하여 성능이 떨어진다.
    
    또한 sum 이라는 메서드의 내용을 수정하고 싶을 때
    
    만들어진 객체만큼 수정작업을 반복해야하는 문제가 있다.
    
    즉 생성자함수는 생산성이 떨어진다.
    
    ```jsx
    function person(name, first, second, third){
    	this.name = name;
    	this.first = first;
    	this.third = third;
    	this.sum = functin(){
    		return this.first+this.second+this.third;
    	}
    }
    
    var kim = new person('kim', 10, 20, 30);
    kim.sum = function(){
    	return 'modified : ' + (this.first + this.second);
    }
    
    var lee = new person('kim', 10, 20, 30);
    
    console.log("kim.sum()", kim.sum());
    console.log("lee.sum()", lee.sum());
    
    ------------------------------------------------
    
    "kim.sum()" , 60
    "lee.sum()" , 30
    
    "kim.sum()" , "modified : 30"
    "lee.sum()" , 30
    ```
    
    Person 이라는 생산자를 이용해 만든 모든 객체가 공통적으로 사용하는 함수와 속성을 만들 수 있다면 편리하겠다.. 라고 생각할 수 있다.
    
    Prototype 만드는 과정
    
    객체를 **재사용** 하자.
    
    위의 객체에는 kim 과 lee 가있다. 생성자를 통해 객체가 있는 것!
    
    이를 활용하여 prototype 라고 하는 객체들 모두가 사용하는 공통속성을 만들어볼 수 있다.
    
    이를 prototype을 정의하는 부분이라고 한다.
    
    프로토타입은 객체생성 함수 안에서 정의하지 않고 밖에서 정의를 한다.
    
    person 이라는 생성자 함수에 sum 이라는 메서드 함수를 만든다.
    
    그 사이에 prototype 을 삽입한다.
    
    프로토타입은 뒤에 있는 person 생성자에 영향을 줄 수 있다. 
    
    뒤에 여러개의 객체가 와도 하나의 함수를 공통적으로 사용할 수 있다.
    
    밑처럼 말이다..!
    
    ```jsx
    function person(name, first, second, third){
    	this.name = name;
    	this.second = second;
    	this.third = third;
    }
    
    person.prototype.sum = function(){
    	return this.first + this.second;
    }
    
    var kim = new person('kim', 10, 20);
    var lee = new person('lee', 10, 20);
    
    console.log("kim.sum()", kim.sum());
    console.log("lee.sum()", lee.sum());
    
    ---------------
    
    "kim.sum()" , 30
    "lee.sum()" , 20
    ```
    
    한편 또 생성자에서 사용되는 공통된 메서드 중 하나의 객체만 다르게 메서드를 만들 수 있다.
    
    하나의 객체만 따로 지정해서 쓰면 그 메서드만 따로 작용가능하다.
    
    ---
    
    ---
    
    ---
    
    공통된 부분이 속한 변수를 만들어 그 변수를 각각 상속시킨다.
    
    ```jsx
    
    const car = {
      wheels : 4,
      drive() {
        console.log("drive..");
      },
    };
    
    const bmw = {
      color : "red",
      navigation:1,
    };
    
    const benz = {
      color: " black",
    };
    
    const audi = {
      color: " blue",
    };
    
    bmw.__proto__ = car;
    benz.__proto__ = car;
    audi.__proto__ = car;
    ```
    
    프로토타입을 만드는 방법
    
    ```jsx
    const car = {
    	wheels = 4;
    	drive(){
    		console.log("drive..");
    	},
    };
    
    const x5 = new Bmw("red");
    const z4 = new Bmw("blue");
    
    x5.__proto__ = car;
    z4.__proto__ = car;
    ```
    
    다음과 같이 변경 가능하다.
    
    ```jsx
    const Bmw = function(color){
    	this.color = color;
    };
    
    Bmw.prototype.wheels = 4;
    Bmw.prototype.drive = function(){
    	console.log("drive..");
    };
    Bmw.prototype.navigation = 1;
    Bmw.prototype.stop = function(){
    	console.log("Stop!!");
    };
    
    const x5 = new Bmw("red");
    const z4 = new Bmw("blue")
    ```
    

---

- 15. 클래스()
    
    자바스크립트는 가장 빠르게 바뀌고 발전되는 언어 중 하나이다.
    
    객체지향언어에서 사용하고있는 문법을 채택함으로써 이미 객체 지향을 사용하는 개발자들이 거부감 없이 적용할 수 있다. 그중 하나가
    
    바로 class 이다.
    
    class 는 객체를 만드는 공장으로써 class 를 지원한다.
    
    이미 객체지향에 익숙한 개발자들이 자바스크립트를 쉽게 사용할 수 있게 해주는 역할을 한다.
    
    class 문법은 자바스크립트의 명제를 담고 잇는 스크립트가 있다.
    
    EC6 이후 작동이 된다는 점 명시할 것!
    
    [https://babeljs.io/](https://babeljs.io/)
    
    해당 사이트는 EC6 이후로 만든 class를 포함한 코드를 호환시키기 위해 활용하기 좋은 사이트이다.
    
    이 사이트를 통해 EC6버전 이후의 코드를 이전코드와 전환가능하다.
    
    생성자 함수는 다음과 같이 정의했었다.
    
    1. 객체를 만든다 ⇒ 2. 객체의 초기상태를 정의한다.
    
    class 는 객체를 만드는 공장이라고 했다. class 를 사용해 객체를 생성해보자.
    
    ```jsx
    class person_
    
    }
    
    var kim = new person();
    console.log('kim', kim);
    
    -------
    "kim"
    [object Object]{...}
    ```
    
    class 에서 생성된 객체는 그럼 어떻게 초기화가 되는걸까?
    
    객체초기 상태를 setting 하는 방법
    
    객체에 속하는 함수를 매서드임을 이젠 잘 알 수 있다.
    
    Javascript Class 에서는 메서드가 어떻게 생성 되는걸까?
    
    Class 안에서는 객체를 만들 때 객체의 초기상태를 만들기 위한 직전에 실행되도록 약속되어있는 함수 constructor(){}를 반드시 사용해야 한다.
    
    함수를 정의하기 위해 function 을 적지 않는다. (매우 중요)
    
    ```jsx
    class person{
    	constructor(name, first, second){
    		console.log('constructor');
    	}
    }
    
    var kim = new person('kim', 10, 20);
    console.log('kim', kim);
    
    ----------
    "constructor"
    "kim"
    [object Object]{...}
    ```
    
    constructor 생성자 함수는 클래스 내에서 객체를 생성할 때
    
    자동으로 호출된다.
    
    ```jsx
    class person{
    	constructor(name, first, second){
    		this.name = name;
    		this.first = first;
    		this.second = second;
    	}
    }
    
    var kim = new person('kim' , 10, 20);
    console.log('kim', kim);
    
    -----------
    "kim"
    [object Object]{
    	first: 10,
    	name: "kim",
    	second: 20
    ]
    ```
    
    class 의 매서드를 만들어 봅시다.
    
    class안에서 메서드를 사용하려 할 때 위에서 class 내부의 정의를 완성한다. 같은 class 에 속해 있는 객체들이 공유하는 메서드임을 알 수 있다. 
    
    prototype에서는 특정 객체의 메서드만 수정하고 싶은 경우 특정 메서드만 따로 지정하면 되었었다.
    
    class 또한 마찬가지로 특정 객체의 메서드만 수정하고 싶다면 프로토타입과 같은 방식을 사용하면 된다.
    
    ```jsx
    class person{
    	constructor(name, first, second){
    		this.name = name;
    		this.first = first;
    		this.second = second;
    }
    sum(){
    	return 'class : ' + (this.first + this.second);
    	}
    }
    
    var kim = new person('kim', 10, 20);
    kim.sum = function(){
    	return 'this: ' + (this.first+this.second);
    }
    
    var lee = new person('lee' , 10, 20);
    
    console.log("kim.sum()", kim.sum());
    console.log("lee.sum()", lee.sum());
    
    --------
    "kim.sum()"
    "this : 30"
    "lee.sum()"
    "class : 20"
    
     
    ```
    
    ---
    
    ---
    
    ---
    
    Class : EC6 에 추가된 스펙이다.
    
    ```jsx
    const User = function(name, age){
    	this.name = name;
    	this.age = age;
    	this.showName = function(){
    		console.log(this.name);
    	};
    };
    
    const mike = new User("Mike", 30);
    ```
    
    위와 아래 스타일의 차이점은?
    
    ```jsx
    class User2{
    	constructor(name, age){
    		this.name = name;
    		this.age = age;
    	}
    	showName(){
    		console.log(this.name)
    	}
    }
    
    const tom = new User2("Tom", 19)
    ```
    

---

- 16. 프로미스()
    
    자바스크립트는 비동기 처리를 위한 하나의 패턴으로 콜백 함수를 사용한다.
    
    하지만 전통적인 콜백 패턴은 콜백헬로 인해 가독성이 나쁘다.
    
    또한 비동기 처리 중 발생한 에러의 처리가 곤란하며 여러개의 비동기 처리를 한번에 처리하는데도 한계가 있다.
    
    ES6 에서는 비동기 처리를 위한 또 다른 패턴으로 프로미스를 도입했다.
    
    프로미스는 전통적인 콜백 패턴이 가진 단점을 보완하며 비동기 처리 시점을 명확하게 표현할 수 있다는 장점이 있다.
    
    Promise 는 비동기 함수를 동기 처리하는 객체 이다.
    
    비동기 작업을 완료하고 다음 작업을 이어서 진행할 수 있는 기능을 가진다.
    
    작업의 성공, 실패를 리턴해서 결과값을 전달받는다.
    
    Promise is a Javascript Object for asynchronous operation
    
    Promise는 자바스크립트 안에 내장된 object 이다.
    
    비동기적인 것을 수행할때 콜백 함수 대신에 사용한다.
    
    프로미스에서 중요한 포인트 두가지
    
    1. State
        
        프로세스가 기능 수행중인지 성공했는지 실패했는지 상태를 아는 것.
        
        pending(대기, 처리중) ⇒ fulfilled(성공, 처리성공) or rejected(거부, 처리실패)
        
    
    ```jsx
    //프로미스 생성
    const foo = function (parameter) {
    	return new Promise (function (resolve, reject){
    		if(parameter){
    			resolve("참 입니다.");
    		} else {
    			reject("거짓 입니다.");
    		}
    	});
    }
    
    //프로미스 실행 1
    foo(true).then(function(resolveText){
    	console.log(resolveText); //참이다.
    }, function(rejectText){
    		console.log(rejectText); //거짓이다.
    });
    
    -----
    참 입니다.
    
    * then(성공콜백함수(promise객체 resolve('이값을 매개변수로), 실패콜백함수(promise객체 reject(이값을 매개변수로))
    
    //프로미스 실행 2
    foo(false).then(function(resolveText){ //then(성공함수) , catch(실패함수)
    	console.log(resolveText); //참 입니다.
    }).catch(function(rejectText){
    	console.log(rejectText); //거짓 입니다.
    });
    
    ---
    거짓 입니다.
    ```
    
    프로미스 체이닝
    
    ```jsx
    var promise = new Promise(function (resolve, reject){
    	setTimeout(function(){
    		resolve(1);
    	}, 1000);
    });
    
    promise.then(function(num){
    	console.log(num); //num=1
    	return num + 1; //num+1 = 1+1 = 2
    }).then(function(value){value = num + 1 = 2
    	console.log(value) //value = 2
    });
    ```
    
    1. Producer vs Consumer
        
        데이터를 제공하는 API와 제공된 데이터를 사용하는 API의 차이점 알기
        
    
    Producer
    
    promise 는 클래스 이기 떄문에 new 로 object를 생성할 수 있다.
    
    promise 는 executor 라는 콜백함수를 전달해줘야 하는데,
    
    excutor 는 두가지 콜백함수 resolve 와 reject 를 받는다.
    
    - resolve : 기능을 정상적으로 수행해서 데이터를 전달
    - rejected : 기능을 수행하다가 문제가 생기면 호출
    
    새로운 promise 가 만들어질 때 excutor 라는 함수가 바로 실행된다.(주의!)
    

---

- 17.  async, await
    
    

---

- 18. Generator

---

- 19. 추가기능